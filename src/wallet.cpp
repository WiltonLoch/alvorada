#include <wallet.hpp>
#include <fstream>
#include <openssl/sha.h>

typedef unsigned char byte;

int Wallet::recoverKey(byte** private_key){
    return false;
}

int Wallet::receiveSeed(byte** seed){
    std::fstream seed_file;
    seed_file.open("seed", std::fstream::in | std::fstream::out);
    if(!seed_file){
        seed_file.open("seed", std::fstream::in | std::fstream::out | std::fstream::trunc);
        if(!generateSeed(seed)) return false;
        for (size_t i = 0; i < sizeof(seed); i++){
            seed_file << seed[i];
        }
    }else{
        for (size_t i = 0; i < sizeof(seed); i++){
            seed_file >> seed[i];
        }
        return true;
    }      
    return false;
}

/**
* This function uses the /dev/urandom linux/unix file to obtain pseudo-random data generated by the O.S.
*/
int Wallet::generateSeed(byte** seed){
    int return_code = RAND_load_file("/dev/urandom", 32);
    unsigned long error = ERR_get_error();
    if (return_code != 32)
    {
        printf("Carregar \"/dev/random\" falhou, err = 0x%lx\n", error);
        return false;
    }

    return_code = RAND_bytes(*seed, sizeof(seed));
    error = ERR_get_error();
    if (return_code != 1)
    {
        printf("A geração do número aleatório falhou, err = 0x%lx\n", error);
        return false;
    }
    return true;
}

int Wallet::generatePublicKey(BIGNUM* private_key, BIGNUM* public_key){
    // EC_GROUP *curve;
    // EC_KEY *key;
    // EC_POINT *public_key_point;
    // if((curve = EC_GROUP_new_by_curve_name(NID_secp256k1)) == NULL) ERR_get_error();
    // if ((key = EC_KEY_new_by_curve_name(NID_secp256k1)) == NULL) ERR_get_error();
    // public_key_point = EC_POINT_new();
    return true;
}

int Wallet::initializeGenerators(){
    byte hashed_seed[64];
    byte seed;

    if(!receiveSeed(&seed)) return false;
    SHA512(seed, sizeof(seed), hashed_seed);

    generator_private_key = BN_new();
    generator_chaincode = BN_new();

    BN_bin2bn(const_cast<const unsigned char*>(hashed_seed), 32, generator_private_key);
    BN_bin2bn(const_cast<const unsigned char*>(hashed_seed + 32), 32, generator_chaincode);    

    if(!generatePublicKey(generator_private_key, generator_public_key)) return false;

    return true;
}