#include <wallet.hpp>
#include <fstream>
#include <openssl/sha.h>

typedef unsigned char byte;

Wallet::Wallet(){}
Wallet::~Wallet(){}

void Wallet::uint2uchar32(byte* retorno, unsigned int valor){
   for(int i = 0; i < 4; i++){
      retorno[3 - i] = valor>>(i*8); 
   }
}

int Wallet::recoverPrivateKey(BIGNUM* private_key){
    return false;
}

int Wallet::receiveSeed(byte** seed){
    std::fstream seed_file;
    seed_file.open("seed", std::fstream::in | std::fstream::out);
    if(!seed_file){
        seed_file.open("seed", std::fstream::in | std::fstream::out | std::fstream::trunc);
        if(!generateSeed(seed)) return false;
        for (size_t i = 0; i < sizeof(seed); i++){
            seed_file << seed[i];
        }
    }else{
        for (size_t i = 0; i < sizeof(seed); i++){
            seed_file >> seed[i];
        }
        return true;
    }      
    return false;
}

/**
* This function uses the /dev/urandom linux/unix file to obtain pseudo-random data generated by the O.S.
*/
int Wallet::generateSeed(byte** seed){
    int return_code = RAND_load_file("/dev/urandom", 32);
    unsigned long error = ERR_get_error();
    if (return_code != 32)
    {
        printf("Carregar \"/dev/random\" falhou, err = 0x%lx\n", error);
        return false;
    }

    return_code = RAND_bytes(*seed, sizeof(seed));
    error = ERR_get_error();
    if (return_code != 1)
    {
        printf("A geração do número aleatório falhou, err = 0x%lx\n", error);
        return false;
    }
    return true;
}

int Wallet::generatePublicKey(BIGNUM* private_key, EC_POINT *public_key){
    if((curve = EC_GROUP_new_by_curve_name(NID_secp256k1)) == NULL) ERR_get_error();    

    public_key = EC_POINT_new(curve);

    if(EC_POINT_mul(curve, public_key, private_key, NULL, NULL, context) != 1) ERR_get_error();

    return true;
}

int Wallet::initializeGenerators(){
    byte hashed_seed[64];
    byte *seed = new unsigned char[32];

    if(!receiveSeed(&seed)) return false;
    SHA512(seed, sizeof(seed), hashed_seed);

    generator_private_key = BN_new();
    generator_chaincode = BN_new();

    BN_bin2bn(const_cast<const unsigned char*>(hashed_seed), 32, generator_private_key);
    BN_bin2bn(const_cast<const unsigned char*>(hashed_seed + 32), 32, generator_chaincode);    

    if(!generatePublicKey(generator_private_key, generator_public_key)) return false;

    return true;
}

int Wallet::generatePrivateKey(BIGNUM* destination, unsigned int key_index){
    byte *composed_seed = new byte[69];
    byte hashed_seed[64];

    BIGNUM *tmp_pub_key = BN_new();

    EC_POINT_point2bn(curve, generator_public_key, POINT_CONVERSION_COMPRESSED, tmp_pub_key, context);

    BN_bn2bin(const_cast<const BIGNUM*>(tmp_pub_key), composed_seed);
    BN_bn2bin(const_cast<const BIGNUM*>(generator_chaincode), composed_seed + 33);
    uint2uchar32(composed_seed + 65, key_index);

    SHA512(composed_seed, sizeof(composed_seed), hashed_seed);

    destination = BN_new();

    BN_bin2bn(const_cast<const unsigned char*>(hashed_seed), 32, destination);

    return true;
}

Key* Wallet::getKey(unsigned int key_index = 0){
    BIGNUM *private_key = nullptr;
    EC_POINT *public_key = nullptr;
    
    EC_KEY *ec_key = nullptr;
    Key *key = nullptr;

    context = BN_CTX_new();

    if ((ec_key = EC_KEY_new_by_curve_name(NID_secp256k1)) == NULL) ERR_get_error();
    if(!recoverPrivateKey(private_key) or key_index > 0) generatePrivateKey(private_key, key_index);
    generatePublicKey(private_key, public_key);

    if (EC_KEY_set_private_key(ec_key, private_key) != 1)    ERR_get_error();
    if (EC_KEY_set_public_key(ec_key, public_key) != 1)   ERR_get_error();

    key = new Key();
    key->setKeyPair(ec_key);
    key->setKeyIndex(key_index);

    return key;
}