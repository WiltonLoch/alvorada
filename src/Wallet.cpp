#include <Wallet.hpp>
#include <fstream>
#include <iostream>
#include <bitset>
#include <openssl/sha.h>

typedef unsigned char byte;

Wallet::Wallet(){}
Wallet::~Wallet(){}

void Wallet::uint2uchar32(byte* retorno, unsigned int valor){
   for(int i = 0; i < 4; i++){
      retorno[3 - i] = valor>>(i*8); 
   }
}
/**
* This function seeks the disk for a previously stored 4 bytes key index.
*/
int Wallet::recoverPrivateKeyIndex(unsigned int *key_index){
    std::fstream key_store_file("key", std::fstream::in);
    if(!key_store_file) return false;

    key_store_file >> *key_index;

    return true;
}
/**
* This function seeks the disk for a previously stored 32 bytes seed, if none is found the generateSeed function 
* is called and the resulting seed is stored on the disk.
*/
int Wallet::receiveSeed(byte** seed){
    std::fstream seed_file;
    seed_file.open("seed", std::fstream::in);
    if(!seed_file){
        seed_file.open("seed", std::fstream::out | std::fstream::trunc);
        if(!generateSeed(seed)) return false;
        for (size_t i = 0; i < 32; i++){
            seed_file << (*seed)[i];
        }
    }else{
        for (size_t i = 0; i < 32; i++){
            seed_file >> (*seed)[i];
        }
    }      
    return true;
}

/**
* This function uses the /dev/urandom linux/unix file to obtain pseudo-random data generated by the O.S.
*/
int Wallet::generateSeed(byte** seed){
    int return_code = RAND_load_file("/dev/urandom", 32);
    unsigned long error = ERR_get_error();
    if (return_code != 32)
    {
        printf("Carregar \"/dev/random\" falhou, err = 0x%lx\n", error);
        return false;
    }

    return_code = RAND_bytes(*seed, 32);
    error = ERR_get_error();
    if (return_code != 1)
    {
        printf("A geração do número aleatório falhou, err = 0x%lx\n", error);
        return false;
    }
    return true;
}

/**
* The first argument is a pointer to a initialized existing private_key and the second is a pointer
* to a non-initialized EC_POINT where the public_key is supposed to be stored. The function executes an EC multiplication
* in order to create a public key from an already created private key. In te same way that Bitcoin does,
* the signature algorithm uses the secp256k1 curve.
*/
int Wallet::generatePublicKey(BIGNUM* private_key, EC_POINT **public_key){
    unsigned long error;

    if((curve = EC_GROUP_new_by_curve_name(NID_secp256k1)) == NULL){
        error = ERR_get_error();    
        printf("Error creating the Eliptic curve = 0x%lx\n", error);
    } 

    *public_key = EC_POINT_new(curve);

    if(EC_POINT_mul(curve, *public_key, private_key, NULL, NULL, context) != 1){
        error = ERR_get_error();
        printf("Error creating the public key = 0x%lx\n", error);
    } 

    return true;
}

/**
* This function initialize the generators. The generators are the first data level for the creation of child keys
* in the HDwallet model: master private key, master public key and chaincode. All these variables are initialized
* from a random seed, provided by other functions in this class. The seed is hashed(SHA512) and the first half
* of the resulting data is used for the master private key, while the second half is assigned as the master chaincode.
* the master public key is naturally obtained from the respective private key.
*/
int Wallet::initializeGenerators(){
    byte hashed_seed[64];
    byte *seed = new unsigned char[32];

    if(!receiveSeed(&seed)) return false;
    SHA512(seed, sizeof(seed), hashed_seed);

    generator_private_key = BN_new();
    generator_chaincode = BN_new();    

    BN_bin2bn(const_cast<const unsigned char*>(hashed_seed), 32, generator_private_key);    

    BN_bin2bn(const_cast<const unsigned char*>(hashed_seed + 32), 32, generator_chaincode); 

    if(!generatePublicKey(generator_private_key, &generator_public_key)) return false;

    return true;
}

/**
* This function generates a new private key. The specific key is created based on the generators(that must be already initialized)
* and the key index, where 0 is the first possible key for that generator set, 1 is the second and so on. The first argument is a 
* pointer for a non-initialized BIGNUM recipient and the second is the key index. The key index used
* as argument is stored for further recovery.
*/
int Wallet::generatePrivateKey(BIGNUM **destination, unsigned int key_index){
    byte *composed_seed = new byte[69];
    byte hashed_seed[64];
    std::fstream key_store_file("key", std::fstream::out | std::fstream::trunc);

    BIGNUM *tmp_pub_key = BN_new();
    EC_POINT_point2bn(curve, generator_public_key, POINT_CONVERSION_COMPRESSED, tmp_pub_key, context);

    BN_bn2bin(const_cast<const BIGNUM*>(tmp_pub_key), composed_seed);
    BN_bn2bin(const_cast<const BIGNUM*>(generator_chaincode), composed_seed + 33);
    uint2uchar32(composed_seed + 65, key_index);

    SHA512(composed_seed, 69, hashed_seed);

    key_store_file << key_index;

    *destination = BN_new();

    BN_bin2bn(const_cast<const unsigned char*>(hashed_seed), 32, *destination);

    return true;
}

/**
* This function is the gateway of the wallet for obtaining keys, the only argument is the key index itself.
* When the key index value is set to zero(default value) the wallet will try to recover a pre-existing key and if no 
* stored key is found, the wallet returns the first key for that generator set. Again, if no generator set is available(
* there is no stored seed), the wallet will create one and return the first key for that set. 
* When the key index is greater than zero, the respective key is returned for that set(if no stored seed is found it is created).
* @return a Key object pointer or nullptr if some process fail
* @param[in] key_index
*/
Key* Wallet::getKey(unsigned int key_index){
    BIGNUM *private_key = nullptr;
    EC_POINT *public_key = nullptr;
    
    EC_KEY *ec_key = nullptr;
    Key *key = nullptr;

    context = BN_CTX_new();
    if ((ec_key = EC_KEY_new_by_curve_name(NID_secp256k1)) == NULL) ERR_get_error();    

    key_index == 0 ? recoverPrivateKeyIndex(&key_index) : key_index--;

    if(!initializeGenerators()) printf("Error on generators initialization!\n");
    generatePrivateKey(&private_key, key_index);
    
    generatePublicKey(private_key, &public_key);
    // printf("key index: %d\n", key_index);
    // printf("priv: %s\n", BN_bn2hex(const_cast<const BIGNUM*>(private_key)));
    // printf("pub: %s\n\n", EC_POINT_point2hex(curve, public_key, POINT_CONVERSION_COMPRESSED, context));

    if (EC_KEY_set_private_key(ec_key, private_key) != 1)    ERR_get_error();
    if (EC_KEY_set_public_key(ec_key, public_key) != 1)   ERR_get_error();

    key = new Key();
    key->setKeyPair(ec_key);
    key->setKeyIndex(key_index);

    return key;
}